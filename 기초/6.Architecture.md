# Componenets

## Master Node
Etcd, kube-scheduler, kube-apiserver, controller manager로 구성

## Worker Node
Kubelet, container runtime, kube-proxy로 구성

### Pod 생성 명령이 왔을 경우
명령-> kube-apiserver-> etcd-> kube-scheduler가 자원을 모니터링 하다가 적절한 node 정보를 etcd안의 pod의 정보에 기입해준다-> wokere node의 kubelet도 kube-apiserver에 연결되어 있기 때문에 자기한테 해당하는 pod의 생성 명령을 kube-proxy에 내려준다-> kube proxy는 container runtime안에 container을 생성

## Deployment 명령이 왔을때
Replicas 정보를 담은 명령-> kube-apiserver을 통해 etcd에 해당 내용 저장-> controller manager은 kube-apiserver에서 해당 내용을 알림 받고 replicaset을 생성할것을 kube-apiserver에 보내준다-> kube-scheduler은 node의 환경을 보고 해당 pod이 어떤 node에 스케쥴링 될지 결정하여 etcd안의 저장정보에 넣어준다-> worker node안의 kubelet은 자신한테 할당된 내용을 확인해 container runtime에서 container을 생성-> kube-proxy 연결


# Networking

## Pod Network
각 pod에는 ip가 할당
Pod이 존재하는 worker node에 network plugin(ex. Calico)이 설치되어 있다
해당 네트워크 플러그인을 통해 route/gateway에 연결한다

### Pause Container
Pod 안의 모든 container가 해당 pod안의 pause container을 사용하여 ip를 공유하게 되고 container별 구별은 port를 통해서 하게된다.
Worker node 안의 Host Network Namespace의 가상 인터페이스와 pause container은 연결이 되어있어 외부 트래픽이 원하는 container에 전달이 될 수 있도록 한다

### Network Plugin
Host Network Namespace안에 pause controller과 연결된 가상 인터페이스들을 연결해주는 bridge 역할을 해준다
Host Network Namespace안에 router을 생성해 해당 대역대의 traffic일 경우에 bridge에 트래픽을 보내준다

## Service Network
각 pod에 service가 연결되고 service 역시 ip를 갖고있다.
Service는 Master Node안의 kube-dns와 api-server에 연결이 돼있다.
Api-server은 해당 worker node안의  NAT에 해당 내용과 연결 돼있어서 pod이 어떤 service로 접근해야 될지 알 수 있게 해준다

### Proxy Mode
Service의 endpoint를 워칭하고 있는 api-server가 트래픽을 받으면 해당 정보와 맞는 worker node안에 있는 kube-proxy에 해당 내용을 전달
* Userspace Mode: pod과 kube-proxy를 iptables를 통해서 연결, 모든 트래픽이 kube-proxy를 거처서 pod network area를 접근한다는 단점이 존재한다
* Iptables/IPVS Mode: kube-proxy에 있는 정보를 iptables에 직접 등록을 하는 방식이라 kube-proxy를 생략하고 pod이 pod network area에 접근


# Storage
